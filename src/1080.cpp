#include <vector>
#include <queue>
#include <iostream>

using namespace std;

struct Country {
    int color = -1; // -1 - не посещен, 0 - красный, 1 - синий
    vector<int> borders;
};

void BFSAndColoring(Country* countries, int st) {
    queue<int> q;
    q.push(st);
    countries[st].color = 0;
    while (!q.empty()) {
        int v = q.front();
        q.pop();
        for (int i = 0; i < countries[v].borders.size(); i++) {
            int to = countries[v].borders[i];
            if (countries[v].color == countries[to].color) {
                cout << "-1";
                exit(0);
            }
            if (countries[to].color == -1) {
                countries[to].color = (countries[v].color == 0 ? 1 : 0);
                q.push(to);
            }
        }
    }
}

int main() {
    int n;
    cin >> n;
    /*
    Здесь (n + 1) для удобства программирования, т.к. страны пронумерованы от 1, а не от 0,
    тогда пускай i ячейке в структуре данных соответсвует i страна.
    */
    Country lands[n + 1];
    for (int i = 1; i <= n; i++) {
        int e = -1;
        while (e != 0) {
            cin >> e;
            if (e != 0) {
                lands[i].borders.push_back(e);
                lands[e].borders.push_back(i);
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        if (lands[i].color == -1) BFSAndColoring(lands, i);
        cout << lands[i].color;
    }
    return 0;
}

/*
Необходимо реализовать алгоритм раскраски графа в 2 цвета так, чтобы смежные вершины не могли быть раскрашены в один цвет. 
Создадим структуру данных Country, которая будет содержать данные о своём цвете и номера стран, с которыми имеет границы. 
На вход алгоритма подаём заполненный невзвешенный граф G = (V, E) и номер стартовой вершины s. На каждом шаге красим одну вершину 
V в определённый цвет в зависимости от того, возможно ли это по условию. В классической реализации необходимо иметь также массив 
used[], который содержит состояние прохода вершины, т.е. была ли она посещена или нет, чтоб исключить добавления её в очередь при 
наличии циклов в графе. В данной задаче от этого можно избавиться, условно покрасив множество {V} в третий цвет до прохода в ширину 
(-1 как-раз может имитировать этот цвет). Сделать это нужно в цикле, так-как граф может быть несвязанным, а значит одного прохода 
может оказаться недостаточно. Запустив алгоритм от каждой непокрашенной вершины, мы точно покроим всем граф.
*/