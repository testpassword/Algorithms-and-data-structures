#include <iostream>
using namespace std;

int main() {
    int t;
    long n, k, teamSize, extTeamSize, remnant;
    cin >> t;
    for (int i = 0; i < t; i++) {
        cin >> n >> k;
        teamSize = n / k;
        remnant = n % k;
        extTeamSize = teamSize + 1;
        cout << ((n - extTeamSize * remnant) * (n - teamSize) + (extTeamSize * remnant) * (n - teamSize - 1)) / 2 << endl;
    }
    return 0;
}

/*
Так как бойцы сражаются "стенка на стенку", необходимо найти, сколько людей в "стенке" у нас будет. n и k даны, значит количество людей в команде = n / k. 
В частном случае задача сводится к простой комбинаторике: каждая человек может сразится с каждом, за исключением его текущим напарников. 
Сложности же задачи добавляет тот факт, что n % k не всегда = 0, а значит надо раскидать оставшихся людей по командам так, чтобы максимизировать количество боёв. 
Так как остаток человек стремится, но никогда не привысит количество команд (в таком случае мы смогли бы сформировать ещё одну команду, что означало бы неккоректность условия), 
можно добавить по человеку из остатка в сформированные команды - такие группы можно называть "расширенными". Теперь можно считать бои. 
Для этого нужно перемножить количество людей в команде (n - extTeamSize * remnant) на количество их противников (n - teamSize) и, 
перемножить количество людей в расширенной команде (extTeamSize * remnant) на количество противников для них (n - teamSize - 1). 
Полученные результаты складываем, для получения всех возможных комбинаций боёв, и делим пополам, чтобы исключить повторяющиеся перестановки.
*/